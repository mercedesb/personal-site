<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-121177820-1"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-121177820-1');</script><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/static/css/app.b0f7990273d7881b9f39b7c6ff3a9367.css" rel="stylesheet"><title>Too much of a good thing? Composition over inheritance | Mercedes Bernard</title><meta name="twitter:card" data-vmid="twitter:card" content="summary" data-vue-meta="true"><meta name="twitter:site" data-vmid="twitter:site" content="@mercedescodes" data-vue-meta="true"><meta name="twitter:creator" data-vmid="twitter:creator" content="@mercedescodes" data-vue-meta="true"><meta property="og:type" data-vmid="og:type" content="article" data-vue-meta="true"><meta property="og:site_name" data-vmid="og:site_name" content="Mercedes Bernard" data-vue-meta="true"><meta property="og:url" data-vmid="og:url" content="http://www.mercedesbernard.com/blog/composition-over-inheritance/" data-vue-meta="true"><meta name="description" data-vmid="description" content="Inheritance gets a bad rap in the programming world, but like anything, it has a time and a place. And composition is not a panacea. It can very quickly turn around and bite us. " data-vue-meta="true"><meta name="og:title" data-vmid="og:title" content="Too much of a good thing? Composition over inheritance" data-vue-meta="true"><meta name="twitter:title" data-vmid="twitter:title" content="Too much of a good thing? Composition over inheritance" data-vue-meta="true"><meta name="twitter:description" data-vmid="twitter:description" content="Inheritance gets a bad rap in the programming world, but like anything, it has a time and a place. And composition is not a panacea. It can very quickly turn around and bite us. " data-vue-meta="true"><meta name="twitter:image" content="http://images.ctfassets.net/kueynwv98jit/2mKaf0vWRygEksCciOeoSK/299318a4372afb3bd8724497e7b2b482/Screen_Shot_2018-07-24_at_9.27.47_AM.png?w=800&amp;fit=fill" data-vue-meta="true"><meta property="og:title" data-vmid="og:title" content="Too much of a good thing? Composition over inheritance" data-vue-meta="true"><meta property="og:image" content="http://images.ctfassets.net/kueynwv98jit/2mKaf0vWRygEksCciOeoSK/299318a4372afb3bd8724497e7b2b482/Screen_Shot_2018-07-24_at_9.27.47_AM.png?w=800&amp;fit=fill" data-vue-meta="true"><meta property="og:description" data-vmid="og:description" content="Inheritance gets a bad rap in the programming world, but like anything, it has a time and a place. And composition is not a panacea. It can very quickly turn around and bite us. " data-vue-meta="true"></head><body><div id="app"><div class="ContentLayout"><main urlsegment="composition-over-inheritance"><header data-v-a4b6b1aa="" class="PageHeader PageHeader--purple PageHeader--short"><!----> <div data-v-a4b6b1aa="" class="PageHeader-text"><div data-v-a4b6b1aa="" class="PageHeader-decorativeHeader"><h2 data-v-a4b6b1aa="">Jul 24 2018</h2></div> <div data-v-a4b6b1aa="" class="PageHeader-titleHeader"><h1 data-v-a4b6b1aa="">Too much of a good thing? Composition over inheritance</h1></div></div> <nav data-v-a4b6b1aa="" class="Navigation"><!----></nav></header> <div><div class="PageContent"><p><span>6 min read</span></p> <div class="Markdown"><p>I recently heard a story about a sous chef in training. He had no experience in a kitchen, and the head chef was getting frustrated by his lack of seasoning and bland dishes. The head chef told the sous chef, "I want you to add salt until you think you’ve added too much and then add some more. I won’t be happy until you have someone send the food back for being too salty.” It took a few hours, but eventually a patron sent back their food. The head chef had proved his point, and the sous chef learned how to properly season his food and the limits of seasoning.</p>
<p>This is how I feel about the programming mantra “composition over inheritance,” where composition is like salt in the kitchen. Experienced chefs know to add salt early and often as salt enhances the natural flavor of most foods, but there can be too much of a good thing.</p>
<p>Before we start, let’s clarify what we mean when we talk about inheritance and composition. Inheritance is when a subclass may use the fields and methods of its parent class. A subclass can override the fields and methods of its parent class to change the functionality. Composition is when a class holds a reference to another object in a field and delegates some responsibility to that object.</p>
<p>“Composition over inheritance” has become one of the most accepted best practices in our industry. And when I learn about the way things “should” be done, I tend to dive in head first and take it to an extreme. Inheritance is bad? I stop using inheritance altogether. Composition is good? I compose anything and everything, even if that means I created an object for a one line method. While this is very obviously not the right way to go, I learn a lot very quickly.</p>
<p>Anything that can be modeled using inheritance can be modeled using composition and this interchangeability can be tricky to get right. We’ve all heard the IS-A vs HAS-A coding idiom and this is a great rule of thumb, but it can be an oversimplification. When some coders (including me) hear that composition is better than inheritance, its really easy to start turning IS-A’s into HAS-A’s in our heads. My experience using composition to such an extreme has taught me that inheritance gets a bad rap in the programming world, but like anything, it has a time and a place. And composition is not a panacea. It can very quickly turn around and bite us.</p>
<p>Inheritance can be extremely useful to add semantic meaning to our code. If we are modeling true IS-A relationships, inheritance is our friend. A new team member will open our code and be able to derive meaning from the inheritance structure. This speeds up onboarding and understanding when our inheritance tree truly models our domain structure.</p>
<p>Inheritance is especially useful when we have a family of objects that share the majority of the same business logic and the differences between them can be thought of as “tweaks.” Tweaks between parents and children should be used to add functionality to the children classes and tweaks between children should be small and localized. If we find ourselves removing functionality as we move around the inheritance tree, we should reevaluate if inheritance is the right solution to this particular problem. And if we find ourselves wanting to share functionality between siblings and cousins, then either our inheritance structure is wrong (less likely) or composition would be a better solution for the problem we are trying to solve (more likely).</p>
<p>To make inheritance successful, we should keep our inheritance trees shallow. The deeper our tree goes, the more consequences we will suffer if we need to make a change near the base of the tree. Its very easy to violate the single responsibility principle if we rely too heavily on inheritance. Even when we’re encapsulating common logic in the parent, our classes should still be small and have high cohesion (keeping similar and related things together and to the point). If we find ourselves with large classes that have a lot of what I like to call “handle methods” then we have probably violated the single responsibility principle. (“Handle methods” are those methods that we can’t come up with a good name for so they all look like “handleWhatever”)</p>
<p>Composition is a great alternative solution to make our code loosely coupled and highly cohesive. When using composition to structure our code, conforming to the single responsibility principle becomes less labor intensive. Creating small classes and composing them together within our objects creates code that welcomes changing requirements. If requirements change and we've used composition to smartly structure our code, we can implement a new instance of the interface and plug that new implementation in place of the old one to meet our changed requirements.</p>
<p>The cost of composition can become too high when our composition trail is winding around and around in our code and becoming difficult to track. If we find ourselves opening file after file to trace what should be a simple solution, then we may be taking the “composition over inheritance” mantra a tad too far. When we can no longer hold the mental model in our brain space, it is overcomplicated. I once worked on a project that took composition so far that no one in the company actually understood how the code fit together, and every story I was assigned included time to unravel the dependency structure and understand what it was that I was trying to build.</p>
<p>Hybrid solutions using both inheritance and composition tend to be the most usable in real-world code. For example, let’s look at how we would model event planning.</p>
<p>Let’s have a base class for Event and some subclasses that inherit from it. Our base Event class will maintain some logic for a guest list to keep track of who we have invited and what they’ve RSVPed.</p>
<pre><code>class Event
  def invited_guests
    @guests
  end

  def attending_guests
    @guests.find_all { |guest|  guest.attending? }
  end

  def not_attending_guests
    @guests.find_all { |guest|  !guest.attending? }
  end
end
</code></pre>
<p>Then for our purposes, let’s say that we have two types of events, Celebration and Meeting. This is an example of inheritance doing what its intended for, a Celebration is an Event and a Meeting is an Event that both have RSVPs to keep track of.</p>
<p>Now let’s add some functionality to one of our subclasses. Most Celebrations have decorations so could add a field to our Celebration class for decorations. This field maintains a list of objects that implement a decoration interface. Meetings do not require decorations so we do not want to put the Decorations field in our base Event class.</p>
<p>Adding the decoration field is an example that highlights the small, additive changes we want to make in child classes when we’re using inheritance and also how to use composition effectively. At a birthday party, we want balloons and streamers but at our Halloween party, we want cobwebs and backlights. By delegating responsibility out to each decoration, we don’t bloat the celebration objects with logic specific to decorations such as decoration cost, supplies needed to hang them, where to purchase them and anything else that decorations care about.</p>
<pre><code>class Celebration &lt; Event
  attr_reader :decorations

  def initialize
    @decorations = []
  end

  def add_decoration(decoration)
    @decorations &lt;&lt; decoration
  end

  def decoration_budget
    @decorations.sum {|decoration| decoration.cost } 
  end
end
</code></pre>
<pre><code>class Meeting &lt; Event
  attr_reader :agenda

  // ... code omitted for brevity

end
</code></pre>
</div> <br> <p class="BlogPost-publishDate"><em>Published Jul 24 2018</em></p></div></div></main></div></div><script type="text/javascript" src="/static/js/manifest.2ae2e69a05c33dfc65f8.js"></script><script type="text/javascript" src="/static/js/vendor.bdfbbe384b0395b368c1.js"></script><script type="text/javascript" src="/static/js/app.616908ae3c151b9d0cca.js"></script></body></html>